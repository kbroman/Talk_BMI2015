// Generated by CoffeeScript 1.10.0
var draw_lod_alltimes, stop_lod_over_time;

draw_lod_alltimes = function(data) {
  var a1, a2, aa, ab, altpink, boundaries, chr, chrEnd, chrEndPixel, chrStart, chrStartPixel, colorScales, curPixel, darkBlue, darkGray, darkRed, e, eff, effCurve, effPlot, effXscale, effYscale, effh, effw, h, hPix, i, imgXscale, imgYscale, imgZscale, imgh, imgw, j, k, l, labelcolor, left, len, len1, len2, len3, len4, lightGray, lodCurve, lodList, lodPlot, lodXscale, lodYscale, lodh, m, maincolor, maxEff, maxLod, maxPhe, maxVal, minEff, minLod, minLodShown, minPhe, mult, n, nPix, nodig, o, onedig, p, pad, panelnames, panels, pheCurve, phePlot, pheYscale, pind, pink, pixelPer, pmarChr, pos, purple, q, r, ref, ref1, ref2, ref3, ref4, ref5, results, s, scale, scaleVals, se, seArea, sePlot, svg, ticks, titlecolor, top, totalh, totalpmar, totalw, twodig, u, v, w, wScale, x, y, ytitle, z;
  d3.select("p#loading").remove();
  pixelPer = 1.5;
  darkBlue = "darkslateblue";
  lightGray = d3.rgb(230, 230, 230);
  darkGray = d3.rgb(200, 200, 200);
  pink = "hotpink";
  altpink = "#E9CFEC";
  purple = "#8C4374";
  darkRed = "crimson";
  labelcolor = "white";
  titlecolor = "Wheat";
  maincolor = "Wheat";
  nodig = d3.format(".0f");
  onedig = d3.format(".1f");
  twodig = d3.format(".2f");
  eff = [];
  for (i in data.ave1) {
    eff[i] = [];
    for (j in data.ave1[i]) {
      eff[i][j] = data.ave2[i][j] - data.ave1[i][j];
    }
  }
  pmarChr = {};
  ref = data.chr;
  for (k = 0, len = ref.length; k < len; k++) {
    chr = ref[k];
    for (p in data.map[chr]) {
      pmarChr[p] = chr;
    }
  }
  minLodShown = 1;
  chrStart = {};
  chrEnd = {};
  chrStartPixel = {};
  chrEndPixel = {};
  ref1 = data.chr;
  for (l = 0, len1 = ref1.length; l < len1; l++) {
    chr = ref1[l];
    chrStart[chr] = 999;
    chrEnd[chr] = -999;
  }
  lodList = [];
  ref2 = data.evenpmar;
  for (pind = m = 0, len2 = ref2.length; m < len2; pind = ++m) {
    p = ref2[pind];
    i = data.pmarindex[p];
    for (j in data.times) {
      chr = pmarChr[p];
      pos = data.map[chr][p];
      if (chrStart[chr] > pos) {
        chrStart[chr] = pos;
      }
      if (chrEnd[chr] < pos) {
        chrEnd[chr] = pos;
      }
      if (data.lod[i][j] > minLodShown) {
        lodList.push({
          pmar: p,
          row: j * 1,
          effindex: pind,
          chr: pmarChr[p],
          xpos: pos,
          value: data.lod[i][j]
        });
      }
    }
  }
  curPixel = 0;
  imgXscale = {};
  lodXscale = {};
  ref3 = data.chr;
  for (n = 0, len3 = ref3.length; n < len3; n++) {
    chr = ref3[n];
    chrStartPixel[chr] = curPixel;
    chrEndPixel[chr] = curPixel + (chrEnd[chr] - chrStart[chr]) * pixelPer;
    curPixel = chrEndPixel[chr] + pixelPer * 2;
    imgXscale[chr] = d3.scale.linear().domain([chrStart[chr], chrEnd[chr]]).range([chrStartPixel[chr], chrEndPixel[chr]]);
    lodXscale[chr] = d3.scale.linear().domain([chrStart[chr], chrEnd[chr]]).range([chrStartPixel[chr] + pixelPer / 2, chrEndPixel[chr] + pixelPer / 2]);
  }
  totalpmar = data.evenpmar.length;
  pad = {
    left: 50,
    top: 20,
    right: 10,
    bottom: 30,
    inner: 2
  };
  imgw = pixelPer * (totalpmar + data.chr.length - 1);
  imgh = pixelPer * data.times.length;
  lodh = 225;
  effh = (imgh - pad.top - pad.bottom) / 2;
  effw = 400;
  h = [imgh, lodh, effh, effh];
  w = [imgw, imgw, effw, effw];
  left = [pad.left, pad.left, pad.left * 2 + w[0] + pad.right, pad.left * 2 + w[0] + pad.right];
  top = [pad.top, pad.top * 2 + h[0] + pad.bottom, pad.top, pad.top * 2 + h[2] + pad.bottom];
  totalh = h[0] + h[1] + (pad.top + pad.bottom) * 2;
  totalw = (w[0] + w[2]) + (pad.left + pad.right) * 2;
  svg = d3.select("div#lod_alltimes_fig").append("svg").attr("height", totalh).attr("width", totalw);
  panels = [];
  panelnames = ["imagepanel", "lodpanel", "phepanel", "effpanel"];
  for (i = o = 0; o < 4; i = ++o) {
    panels[i] = svg.append("g").attr("id", panelnames[i]).attr("transform", "translate(" + left[i] + ", " + top[i] + ")");
  }
  for (i = q = 0; q <= 3; i = ++q) {
    panels[i].append("rect").attr("height", h[i]).attr("width", w[i]).attr("fill", "white").attr("stroke", "black").attr("stroke-width", 2);
  }
  minEff = 0;
  maxEff = 0;
  minPhe = data.ave1[0][0];
  maxPhe = data.ave1[0][0];
  for (i in data.ave1) {
    for (j in data.ave1[i]) {
      a1 = data.ave1[i][j];
      a2 = data.ave2[i][j];
      e = eff[i][j];
      se = data.se[i][j];
      if (minPhe > a1) {
        minPhe = a1;
      }
      if (maxPhe < a1) {
        maxPhe = a1;
      }
      if (minPhe > a2) {
        minPhe = a2;
      }
      if (maxPhe < a2) {
        maxPhe = a2;
      }
      if (minEff > e - 2 * se) {
        minEff = e - 2 * se;
      }
      if (maxEff < e + 2 * se) {
        maxEff = e + 2 * se;
      }
    }
  }
  maxLod = -1;
  minLod = 50;
  for (i in data.lod) {
    for (j in data.lod[i]) {
      if (maxLod < data.lod[i][j]) {
        maxLod = data.lod[i][j];
      }
      if (minLod > data.lod[i][j]) {
        minLod = data.lod[i][j];
      }
    }
  }
  if (-minEff > maxEff) {
    maxEff = -minEff;
  }
  if (-maxEff < minEff) {
    minEff = -maxEff;
  }
  effYscale = d3.scale.linear().domain([minEff, maxEff]).range([effh - pad.inner, pad.inner]);
  pheYscale = d3.scale.linear().domain([minPhe, maxPhe]).range([effh - pad.inner, pad.inner]);
  lodYscale = d3.scale.linear().domain([0, maxLod]).range([lodh - pad.inner, pad.inner]);
  imgYscale = d3.scale.ordinal().domain(d3.range(data.times.length)).rangePoints([imgh - pixelPer, 0], 0);
  imgZscale = d3.scale.linear().domain([0, maxLod]).range([0, 1]).clamp(true);
  effXscale = d3.scale.linear().domain([d3.min(data.times), d3.max(data.times)]).range([pad.inner, w[2] - pad.inner]);
  boundaries = [];
  ref4 = data.chr.slice(1);
  for (r = 0, len4 = ref4.length; r < len4; r++) {
    chr = ref4[r];
    boundaries.push(chrStartPixel[chr]);
  }
  for (i = s = 0; s <= 1; i = ++s) {
    panels[i].append("g").attr("id", "chrBoundaryLines").selectAll("empty").data(boundaries).enter().append("line").attr("y1", 0).attr("y2", h[i]).attr("x1", function(d) {
      return d - pixelPer * 0.5;
    }).attr("x2", function(d) {
      return d - pixelPer * 0.5;
    }).attr("fill", "none").attr("stroke", "darkGray").attr("stroke-width", 1);
  }
  for (i = u = 2; u <= 3; i = ++u) {
    panels[i].selectAll("empty").data([0, 1, 2, 3, 4, 5, 6, 7, 8]).enter().append("line").attr("y1", 0).attr("y2", h[i]).attr("x1", function(d) {
      return effXscale(d * 60);
    }).attr("x2", function(d) {
      return effXscale(d * 60);
    }).attr("fill", "none").attr("stroke", "darkGray").attr("stroke-width", 1);
    panels[i].selectAll("empty").data([0, 1, 2, 3, 4, 5, 6, 7, 8]).enter().append("text").text(function(d) {
      return d;
    }).attr("y", h[i] + pad.bottom * 0.5).attr("x", function(d) {
      return effXscale(d * 60);
    }).attr("fill", labelcolor).attr("text-anchor", "middle");
  }
  panels[3].append("text").text("Time (hours)").attr("x", w[3] / 2).attr("y", h[3] + pad.bottom).attr("fill", titlecolor).attr("text-anchor", "middle");
  for (i = v = 0; v <= 1; i = ++v) {
    panels[i].append("g").attr("id", "chrLabels").selectAll("empty").data(data.chr).enter().append("text").attr("y", h[i] + pad.bottom * 0.42).attr("x", function(d) {
      return (chrStartPixel[d] + chrEndPixel[d]) / 2;
    }).text(function(d) {
      return d;
    }).attr("fill", labelcolor).attr("text-anchor", "middle");
  }
  panels[1].append("text").text("Chromosome").attr("fill", titlecolor).attr("text-anchor", "middle").attr("x", w[1] / 2).attr("y", h[1] + pad.bottom * 0.9);
  panels[0].append("g").attr("id", "imgYaxisLabels").selectAll("empty").data([0, 1, 2, 3, 4, 5, 6, 7, 8]).enter().append("text").text(function(d) {
    return d;
  }).attr("x", -pad.left * 0.1).attr("y", function(d) {
    return imgYscale(d * 30);
  }).attr("fill", labelcolor).attr("text-anchor", "end").attr("dominant-baseline", "middle");
  panels[0].append("g").attr("id", "imgYaxisGridlines").selectAll("empty").data([1, 2, 3, 4, 5, 6, 7]).enter().append("line").attr("y1", function(d) {
    return imgYscale(d * 30);
  }).attr("y2", function(d) {
    return imgYscale(d * 30);
  }).attr("x1", 0).attr("x2", w[0]).attr("fill", "none").attr("stroke", "lightGray").attr("stroke-width", 1);
  panels[0].append("text").text("Time (hours)").attr("x", -pad.left * 0.6).attr("y", h[0] / 2).attr("text-anchor", "middle").attr("dominant-baseline", "middle").attr("transform", "rotate(270, " + (-pad.left * 0.6) + ", " + (h[0] / 2) + ")").attr("fill", titlecolor);
  ticks = [null, lodYscale.ticks(5), pheYscale.ticks(6), effYscale.ticks(6)];
  scale = [null, lodYscale, pheYscale, effYscale];
  ytitle = [null, "LOD score", "Ave phenotype", "QTL effect (BB - AA)"];
  mult = [null, 0.6, 0.8, 0.7];
  for (i = x = 1; x <= 3; i = ++x) {
    panels[i].selectAll("empty").data(ticks[i]).enter().append("text").text(function(d) {
      return nodig(d);
    }).attr("x", -pad.left * 0.1).attr("y", function(d) {
      return scale[i](d);
    }).attr("fill", function(d) {
      if (d === 0 && i === 3) {
        return pink;
      }
      return labelcolor;
    }).attr("text-anchor", "end").attr("dominant-baseline", "middle");
    panels[i].selectAll("empty").data(ticks[i]).enter().append("line").attr("y1", function(d) {
      return scale[i](d);
    }).attr("y2", function(d) {
      return scale[i](d);
    }).attr("x1", 0).attr("x2", w[i]).attr("fill", "none").attr("stroke", function(d) {
      if (d === 0 && i === 3) {
        return pink;
      }
      return "lightGray";
    }).attr("stroke-width", 1);
    panels[i].append("text").text(ytitle[i]).attr("x", -pad.left * mult[i]).attr("y", h[i] / 2).attr("text-anchor", "middle").attr("dominant-baseline", "middle").attr("transform", "rotate(270, " + (-pad.left * mult[i]) + ", " + (h[i] / 2) + ")").attr("fill", titlecolor);
  }
  panels[2].selectAll("empty").data(["AA", "BB"]).enter().append("text").text(function(d) {
    return d;
  }).attr("x", function(d, i) {
    return effXscale((6.5 + i) * 60);
  }).attr("y", pheYscale(-20) / 2).attr("fill", function(d, g) {
    if (g === 0) {
      return darkBlue;
    }
    return darkRed;
  }).attr("text-anchor", "middle").attr("dominant-baseline", "middle");
  pheCurve = function(pmari, g) {
    return d3.svg.line().x(function(t) {
      return effXscale(t);
    }).y(function(t, i) {
      if (g === 1) {
        return pheYscale(data.ave1[pmari][i]);
      } else {
        return pheYscale(data.ave2[pmari][i]);
      }
    });
  };
  phePlot = function(pmari) {
    var g, pmar, y;
    for (g = y = 1; y <= 2; g = ++y) {
      panels[2].append("path").attr("id", "pheCurve" + g).datum(data.times).attr("d", pheCurve(pmari, g)).attr("stroke", function() {
        if (g === 1) {
          return darkBlue;
        }
        return darkRed;
      }).attr("fill", "none").attr("stroke-width", "2");
    }
    pmar = data.evenpmar[pmari];
    chr = pmarChr[pmar];
    pos = data.map[chr][pmar];
    return panels[2].append("text").attr("id", "pheTitle").text("Chr " + chr + " @ " + (nodig(pos)) + " cM").attr("x", w[2] / 2).attr("y", -pad.top * 0.6).attr("text-anchor", "middle").attr("dominant-baseline", "middle").attr("fill", maincolor);
  };
  effCurve = function(pmari) {
    return d3.svg.line().x(function(t) {
      return effXscale(t);
    }).y(function(t, i) {
      return effYscale(eff[pmari][i]);
    });
  };
  seArea = function(pmari) {
    return d3.svg.area().x(function(t) {
      return effXscale(t);
    }).y0(function(t, i) {
      return effYscale(eff[pmari][i] - 2 * data.se[pmari][i]);
    }).y1(function(t, i) {
      return effYscale(eff[pmari][i] + 2 * data.se[pmari][i]);
    });
  };
  effPlot = function(pmari) {
    return panels[3].append("path").attr("id", "effCurve").datum(data.times).attr("d", effCurve(pmari)).attr("stroke", darkBlue).attr("fill", "none").attr("stroke-width", "2");
  };
  sePlot = function(pmari) {
    return panels[3].append("path").attr("id", "seArea").datum(data.times).attr("d", seArea(pmari)).attr("stroke", "none").attr("fill", "lightblue").attr("opacity", 0.3);
  };
  lodCurve = function(time, chr) {
    return d3.svg.line().x(function(pmar) {
      return lodXscale[chr](data.map[chr][pmar]);
    }).y(function(pmar) {
      return lodYscale(data.lod[data.pmarindex[pmar]][time]);
    });
  };
  lodPlot = function(time) {
    var len5, ref5, results, retime, y;
    retime = Math.floor(time * 2 / 60) + Math.round(time * 2 % 60) / 100;
    retime = twodig(retime);
    retime = retime.replace(/\./, ":");
    panels[1].append("text").attr("id", "lodTitle").text("time = " + retime).attr("x", w[1] / 2).attr("y", -pad.top * 0.6).attr("fill", maincolor).attr("text-anchor", "middle").attr("dominant-baseline", "middle");
    ref5 = data.chr;
    results = [];
    for (y = 0, len5 = ref5.length; y < len5; y++) {
      chr = ref5[y];
      results.push(panels[1].append("path").attr("id", "lodCurve" + chr).datum(data.allpmar[chr]).attr("d", lodCurve(time, chr)).attr("stroke", darkBlue).attr("fill", "none").attr("stroke-width", "2"));
    }
    return results;
  };
  panels[0].append("g").attr("id", "imagerect").selectAll("empty").data(lodList).enter().append("rect").attr("x", function(d) {
    return imgXscale[d.chr](d.xpos);
  }).attr("width", pixelPer).attr("y", function(d) {
    return imgYscale(d.row);
  }).attr("height", pixelPer).attr("fill", function(d) {
    if (eff[d.effindex][d.row] < 0) {
      return darkBlue;
    }
    return darkRed;
  }).attr("stroke", function(d) {
    if (eff[d.effindex][d.row] < 0) {
      return darkBlue;
    }
    return darkRed;
  }).attr("stroke-width", 0).attr("opacity", function(d) {
    return imgZscale(d.value);
  }).on("mouseover", function(d) {
    effPlot(d.effindex);
    phePlot(d.effindex);
    return lodPlot(d.row);
  }).on("click", function(d) {
    panels[3].select("path#seArea").remove();
    return sePlot(d.effindex);
  }).on("mouseout", function() {
    var g, len5, ref5, y, z;
    panels[3].select("path#effCurve").remove();
    panels[3].select("path#seArea").remove();
    for (g = y = 1; y <= 2; g = ++y) {
      panels[2].select("path#pheCurve" + g).remove();
    }
    panels[2].select("text#pheTitle").remove();
    ref5 = data.chr;
    for (z = 0, len5 = ref5.length; z < len5; z++) {
      chr = ref5[z];
      panels[1].select("path#lodCurve" + chr).remove();
    }
    return panels[1].select("text#lodTitle").remove();
  });
  wScale = 25;
  colorScales = [];
  colorScales[0] = panels[1].append("g").attr("id", "blueColorScale").attr("transform", "translate(" + (w[1] + pad.right) + ", 0)");
  colorScales[1] = panels[1].append("g").attr("id", "redColorScale").attr("transform", "translate(" + (w[1] + pad.right * 2 + wScale) + ", 0)");
  for (i = y = 0; y <= 1; i = ++y) {
    colorScales[i].append("rect").attr("x", 0).attr("y", 0).attr("width", wScale).attr("height", h[1]).attr("fill", "white").attr("stroke", "black").attr("stroke-width", 2);
  }
  colorScales[0].append("text").text("Color scales").attr("x", wScale + pad.right / 2).attr("y", -pad.top * 0.5).attr("fill", titlecolor).attr("text-anchor", "middle").attr("dominant-baseline", "middle");
  colorScales[1].selectAll("empty").data(ticks[1]).enter().append("text").text(function(d) {
    return nodig(d);
  }).attr("x", wScale + pad.left * 0.1).attr("y", function(d) {
    return scale[1](d);
  }).attr("fill", labelcolor).attr("text-anchor", "start").attr("dominant-baseline", "middle");
  for (i = z = 0; z <= 1; i = ++z) {
    colorScales[i].selectAll("empty").data(ticks[1]).enter().append("line").attr("y1", function(d) {
      return scale[1](d);
    }).attr("y2", function(d) {
      return scale[1](d);
    }).attr("x1", 0).attr("x2", wScale).attr("fill", "none").attr("stroke", lightGray).attr("stroke-width", 1);
  }
  colorScales[0].selectAll("empty").data(ticks[1]).enter().append("line").attr("y1", function(d) {
    return scale[1](d);
  }).attr("y2", function(d) {
    return scale[1](d);
  }).attr("x1", wScale).attr("x2", wScale + pad.right).attr("fill", "none").attr("stroke", "white").attr("stroke-width", 1);
  scaleVals = [];
  nPix = 128;
  hPix = h[1] / nPix;
  maxVal = maxLod / (h[1] - pad.inner * 2) * h[1];
  for (i = aa = 0, ref5 = nPix; 0 <= ref5 ? aa < ref5 : aa > ref5; i = 0 <= ref5 ? ++aa : --aa) {
    scaleVals.push(i * hPix / h[1] * maxVal);
  }
  results = [];
  for (i = ab = 0; ab <= 1; i = ++ab) {
    results.push(colorScales[i].append("g").attr("id", "blueScaleRect").selectAll("empty").data(scaleVals).enter().append("rect").attr("x", 0).attr("width", wScale).attr("y", function(d) {
      return lodYscale(d);
    }).attr("height", hPix).attr("fill", function(d) {
      if (i === 0) {
        return darkBlue;
      }
      return darkRed;
    }).attr("stroke", "none").attr("stroke-width", 0).attr("opacity", function(d) {
      if (d >= 1) {
        return imgZscale(d);
      }
      if (d >= maxLod) {
        return 1;
      }
      return 0;
    }));
  }
  return results;
};

stop_lod_over_time = function() {
  return d3.selectAll("div#lod_alltimes_fig svg").remove();
};
