// Generated by CoffeeScript 1.10.0
var draw_cistrans, stop_cistrans;

draw_cistrans = function(data) {
  var Zscale, aa, altpink, axislabels, bigRad, bottom, c, checkerboard, checkerboard2, chrGap, chrLowXScale, chrXScale, chrYScale, chrindex, ci, cj, cur, curXPixel, curYPixel, darkGray, darkblue, darkgreen, darkred, draw_probe, efftip, eqtltip, fasttime, g, h, i, indtip, j, jitter, jitterAmount, k, l, labelcolor, left, len, len1, len10, len2, len3, len4, len5, len6, len7, len8, len9, lightGray, m, maincolor, martip, maxlod, newg, nodig, o, onedig, p, pad, peakRad, peaks, pink, purple, pxgXscaleA, pxgXscaleX, q, r, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, results, right, s, slowtime, svg, t, tickHeight, titlecolor, top, totalChrLength, totalh, totalw, twodig, u, v, w, xloc, y, yloc;
  w = [500, 300];
  h = [w[0], 200];
  pad = {
    left: 60,
    top: 40,
    right: 40,
    bottom: 40,
    inner: 10
  };
  w = [w[0], w[0] + w[1] + pad.left + pad.right, w[1]];
  h = [h[0], h[1], h[0]];
  left = [pad.left, pad.left, pad.left + w[0] + pad.right + pad.left];
  top = [pad.top, pad.top + h[0] + pad.bottom + pad.top, pad.top];
  right = [];
  bottom = [];
  for (i in left) {
    right[i] = left[i] + w[i];
    bottom[i] = top[i] + h[i];
  }
  totalw = right[2] + pad.right;
  totalh = bottom[1] + pad.bottom;
  peakRad = 2;
  bigRad = 5;
  chrGap = 8;
  slowtime = 1000;
  fasttime = 250;
  tickHeight = (bottom[1] - top[1]) * 0.02;
  jitterAmount = (right[2] - left[2]) / 50;
  jitter = [];
  for (i in data.individuals) {
    jitter[i] = (2.0 * Math.random() - 1.0) * jitterAmount;
  }
  nodig = d3.format(".0f");
  onedig = d3.format(".1f");
  twodig = d3.format(".2f");
  lightGray = d3.rgb(200, 200, 200);
  darkGray = d3.rgb(170, 170, 170);
  darkblue = "darkslateblue";
  darkgreen = "darkslateblue";
  pink = "hotpink";
  altpink = "#E9CFEC";
  purple = "#8C4374";
  darkred = "crimson";
  labelcolor = "white";
  titlecolor = "Wheat";
  maincolor = "Wheat";
  totalChrLength = 0;
  ref = data.chrnames;
  for (k = 0, len = ref.length; k < len; k++) {
    c = ref[k];
    data.chr[c].length_cM = data.chr[c].end_cM - data.chr[c].start_cM;
    totalChrLength += data.chr[c].length_cM;
  }
  chrXScale = {};
  chrYScale = {};
  curXPixel = left[0] + peakRad;
  curYPixel = bottom[0] - peakRad;
  ref1 = data.chrnames;
  for (l = 0, len1 = ref1.length; l < len1; l++) {
    c = ref1[l];
    data.chr[c].length_pixel = Math.round((w[0] - peakRad * 2) * data.chr[c].length_cM / totalChrLength);
    data.chr[c].start_Xpixel = curXPixel;
    data.chr[c].end_Xpixel = curXPixel + data.chr[c].length_pixel - 1;
    data.chr[c].start_Ypixel = curYPixel;
    data.chr[c].end_Ypixel = curYPixel - (data.chr[c].length_pixel - 1);
    chrXScale[c] = d3.scale.linear().domain([data.chr[c].start_cM, data.chr[c].end_cM]).range([data.chr[c].start_Xpixel, data.chr[c].end_Xpixel]).clamp(true);
    chrYScale[c] = d3.scale.linear().domain([data.chr[c].start_cM, data.chr[c].end_cM]).range([data.chr[c].start_Ypixel, data.chr[c].end_Ypixel]).clamp(true);
    curXPixel += data.chr[c].length_pixel;
    curYPixel -= data.chr[c].length_pixel;
  }
  top[0] = data.chr["X"].end_Ypixel - peakRad;
  h[0] = bottom[0] - top[0];
  data.chr["1"].start_Xpixel = left[0];
  data.chr["1"].start_Ypixel = bottom[0];
  data.chr["X"].end_Xpixel = right[0];
  data.chr["X"].end_Ypixel = top[0];
  chrLowXScale = {};
  cur = Math.round(pad.left + chrGap / 2);
  ref2 = data.chrnames;
  for (o = 0, len2 = ref2.length; o < len2; o++) {
    c = ref2[o];
    data.chr[c].start_lowerXpixel = cur;
    data.chr[c].end_lowerXpixel = cur + Math.round((w[1] - chrGap * data.chrnames.length) / totalChrLength * data.chr[c].length_cM);
    chrLowXScale[c] = d3.scale.linear().domain([data.chr[c].start_cM, data.chr[c].end_cM]).range([data.chr[c].start_lowerXpixel, data.chr[c].end_lowerXpixel]);
    cur = data.chr[c].end_lowerXpixel + chrGap;
  }
  pxgXscaleA = d3.scale.ordinal().domain(d3.range(6)).rangePoints([left[2], right[2]], 1);
  pxgXscaleX = d3.scale.ordinal().domain(d3.range(4)).rangePoints([left[2], right[2]], 1);
  ref3 = data.markers;
  for (q = 0, len3 = ref3.length; q < len3; q++) {
    m = ref3[q];
    if (data.pmark[m].chr !== "X") {
      continue;
    }
    ref4 = data.geno[m];
    for (i = r = 0, len4 = ref4.length; r < len4; i = ++r) {
      g = ref4[i];
      if (data.sex[i] === 0) {
        newg = 0;
        switch (g) {
          case -1:
            newg = -2;
            break;
          case -2:
            newg = -1;
            break;
          case +1:
            newg = +2;
            break;
          case +2:
            newg = +1;
        }
        data.geno[m][i] = newg;
      }
    }
  }
  svg = d3.select("div#cistrans").append("svg").attr("width", totalw).attr("height", totalh);
  for (j in left) {
    svg.append("rect").attr("x", left[j]).attr("y", top[j]).attr("height", h[j]).attr("width", w[j]).attr("class", "innerBox");
  }
  checkerboard = svg.append("g").attr("id", "checkerboard");
  ref5 = data.chrnames;
  for (i = s = 0, len5 = ref5.length; s < len5; i = ++s) {
    ci = ref5[i];
    ref6 = data.chrnames;
    for (j = t = 0, len6 = ref6.length; t < len6; j = ++t) {
      cj = ref6[j];
      if ((i + j) % 2 === 0) {
        checkerboard.append("rect").attr("x", data.chr[ci].start_Xpixel).attr("width", data.chr[ci].end_Xpixel - data.chr[ci].start_Xpixel).attr("y", data.chr[cj].end_Ypixel).attr("height", data.chr[cj].start_Ypixel - data.chr[cj].end_Ypixel).attr("stroke", "none").attr("fill", darkGray).style("pointer-events", "none");
      }
    }
  }
  checkerboard2 = svg.append("g").attr("id", "checkerboard2");
  ref7 = data.chrnames;
  for (i = u = 0, len7 = ref7.length; u < len7; i = ++u) {
    ci = ref7[i];
    if (i % 2 === 0) {
      checkerboard2.append("rect").attr("x", data.chr[ci].start_lowerXpixel - chrGap / 2).attr("width", data.chr[ci].end_lowerXpixel - data.chr[ci].start_lowerXpixel + chrGap).attr("y", top[1]).attr("height", h[1]).attr("stroke", "none").attr("fill", darkGray).style("pointer-events", "none");
    }
  }
  axislabels = svg.append("g").attr("id", "axislabels").style("pointer-events", "none");
  axislabels.append("g").attr("id", "topleftX").selectAll("empty").data(data.chrnames).enter().append("text").text(function(d) {
    return d;
  }).attr("x", function(d) {
    return (data.chr[d].start_Xpixel + data.chr[d].end_Xpixel) / 2;
  }).attr("y", bottom[0] + pad.bottom * 0.3).attr("fill", labelcolor);
  axislabels.append("g").attr("id", "topleftY").selectAll("empty").data(data.chrnames).enter().append("text").text(function(d) {
    return d;
  }).attr("x", left[0] - pad.left * 0.15).attr("y", function(d) {
    return (data.chr[d].start_Ypixel + data.chr[d].end_Ypixel) / 2;
  }).style("text-anchor", "end").attr("fill", labelcolor);
  axislabels.append("g").attr("id", "bottomX").selectAll("empty").data(data.chrnames).enter().append("text").text(function(d) {
    return d;
  }).attr("x", function(d) {
    return (data.chr[d].start_lowerXpixel + data.chr[d].end_lowerXpixel) / 2;
  }).attr("y", bottom[1] + pad.bottom * 0.3).attr("fill", labelcolor);
  axislabels.append("text").text("Marker position (cM)").attr("x", (left[0] + right[0]) / 2).attr("y", bottom[0] + pad.bottom * 0.75).attr("fill", titlecolor).attr("text-anchor", "middle");
  axislabels.append("text").text("Position (cM)").attr("x", (left[1] + right[1]) / 2).attr("y", bottom[1] + pad.bottom * 0.75).attr("fill", titlecolor).attr("text-anchor", "middle");
  xloc = left[0] - pad.left * 0.65;
  yloc = (top[0] + bottom[0]) / 2;
  axislabels.append("text").text("Probe position (cM)").attr("x", xloc).attr("y", yloc).attr("transform", "rotate(270," + xloc + "," + yloc + ")").style("text-anchor", "middle").attr("fill", titlecolor);
  xloc = left[1] - pad.left * 0.65;
  yloc = (top[1] + bottom[1]) / 2;
  axislabels.append("text").text("LOD score").attr("x", xloc).attr("y", yloc).attr("transform", "rotate(270," + xloc + "," + yloc + ")").style("text-anchor", "middle").attr("fill", titlecolor);
  maxlod = d3.max(data.peaks, function(d) {
    return d.lod;
  });
  data.peaks = data.peaks.sort(function(a, b) {
    if (a.lod < b.lod) {
      return -1;
    } else {
      return +1;
    }
  });
  Zscale = d3.scale.linear().domain([0, 25]).range([0, 1]);
  eqtltip = d3.svg.tip().orient("right").padding(3).text(function(z) {
    return z.probe + " (LOD = " + (onedig(z.lod)) + ")";
  }).attr("class", "d3-tip").attr("id", "eqtltip");
  martip = d3.svg.tip().orient("right").padding(3).text(function(z) {
    return z;
  }).attr("class", "d3-tip").attr("id", "martip");
  indtip = d3.svg.tip().orient("right").padding(3).text(function(d, i) {
    return data.individuals[i];
  }).attr("class", "d3-tip").attr("id", "indtip");
  efftip = d3.svg.tip().orient("right").padding(3).text(function(d) {
    return twodig(d);
  }).attr("class", "d3-tip").attr("id", "efftip");
  cur = 0;
  ref8 = data.chrnames;
  for (v = 0, len8 = ref8.length; v < len8; v++) {
    c = ref8[v];
    ref9 = data.pmarknames[c];
    for (y = 0, len9 = ref9.length; y < len9; y++) {
      p = ref9[y];
      data.pmark[p].index = cur;
      cur++;
    }
  }
  draw_probe = function(probe_data) {
    var aa, ab, ac, chr, curves, draw_pxgXaxis, ensembl, gene, lastMarker, len10, len11, len12, lod, lodcurve, lodcurve_yScale, markerClick, maxlod_marker, meanmarks, mgi, plotPXG, pos, probeaxes, pxgXaxis, pxgYaxis, pxgYscale, ref10, ref11, ref12, revPXG, ticks, title, titletext, xlink, yaxis;
    svg.selectAll(".probe_data").remove();
    d3.select("text#pxgtitle").text("");
    svg.selectAll(".plotPXG").remove();
    maxlod = -1;
    maxlod_marker = null;
    ref10 = data.markers;
    for (aa = 0, len10 = ref10.length; aa < len10; aa++) {
      m = ref10[aa];
      lod = probe_data.lod[data.pmark[m].index];
      if (maxlod < lod) {
        maxlod = lod;
        maxlod_marker = m;
      }
    }
    lodcurve_yScale = d3.scale.linear().domain([0, maxlod * 1.05]).range([bottom[1], top[1]]);
    yaxis = svg.append("g").attr("class", "probe_data").attr("id", "loweryaxis");
    ticks = lodcurve_yScale.ticks(6);
    yaxis.selectAll("empty").data(ticks).enter().append("line").attr("y1", function(d) {
      return lodcurve_yScale(d);
    }).attr("y2", function(d) {
      return lodcurve_yScale(d);
    }).attr("x1", left[1]).attr("x2", right[1]).attr("stroke", "white").attr("stroke-width", "1");
    yaxis.selectAll("empty").data(ticks).enter().append("text").text(function(d) {
      if (maxlod > 10) {
        return nodig(d);
      } else {
        return onedig(d);
      }
    }).attr("y", function(d) {
      return lodcurve_yScale(d);
    }).attr("x", left[1] - pad.left * 0.1).style("text-anchor", "end").attr("fill", labelcolor);
    yaxis.append("line").attr("y1", lodcurve_yScale(5)).attr("y2", lodcurve_yScale(5)).attr("x1", left[1]).attr("x2", right[1]).attr("stroke", purple).attr("stroke-width", "1").attr("stroke-dasharray", "2,2");
    lodcurve = function(c) {
      return d3.svg.line().x(function(p) {
        return chrLowXScale[c](data.pmark[p].pos_cM);
      }).y(function(p) {
        return lodcurve_yScale(probe_data.lod[data.pmark[p].index]);
      });
    };
    curves = svg.append("g").attr("id", "curves").attr("class", "probe_data");
    ref11 = data.chrnames;
    for (ab = 0, len11 = ref11.length; ab < len11; ab++) {
      c = ref11[ab];
      curves.append("path").datum(data.pmarknames[c]).attr("d", lodcurve(c)).attr("class", "thickline").attr("stroke", darkblue).style("pointer-events", "none").attr("fill", "none");
    }
    titletext = probe_data.probe;
    probeaxes = svg.append("g").attr("id", "probe_data_axes").attr("class", "probe_data");
    gene = data.probes[probe_data.probe].gene;
    ensembl = "http://www.ensembl.org/Mus_musculus/Search/Details?db=core;end=1;idx=Gene;species=Mus_musculus;q=" + gene;
    mgi = "http://www.informatics.jax.org/searchtool/Search.do?query=" + gene;
    if (gene !== null) {
      titletext += " (" + gene + ")";
      xlink = probeaxes.append("a").attr("xlink:href", mgi);
      xlink.append("text").text(titletext).attr("x", (left[1] + right[1]) / 2).attr("y", top[1] - pad.top / 2).attr("fill", maincolor).style("font-size", "18px");
    } else {
      probeaxes.append("text").text(titletext).attr("x", (left[1] + right[1]) / 2).attr("y", top[1] - pad.top / 2).attr("fill", maincolor).style("font-size", "18px");
    }
    svg.append("rect").attr("class", "probe_data").attr("x", left[1]).attr("y", top[1]).attr("height", h[1]).attr("width", w[1]).attr("class", "outerBox");
    svg.append("circle").attr("class", "probe_data").attr("id", "probe_circle").attr("cx", chrLowXScale[data.probes[probe_data.probe].chr](data.probes[probe_data.probe].pos_cM)).attr("cy", top[1]).attr("r", bigRad).attr("fill", pink).attr("stroke", darkblue).attr("stroke-width", 1).attr("opacity", 1);
    svg.append("text").attr("id", "pxgtitle").attr("x", (left[2] + right[2]) / 2).attr("y", pad.top / 2).text("").attr("fill", maincolor);
    markerClick = {};
    ref12 = data.markers;
    for (ac = 0, len12 = ref12.length; ac < len12; ac++) {
      m = ref12[ac];
      markerClick[m] = 0;
    }
    lastMarker = "";
    svg.append("g").attr("id", "markerCircle").attr("class", "probe_data").selectAll("empty").data(data.markers).enter().append("circle").attr("class", "probe_data").attr("id", function(td) {
      return "marker_" + td;
    }).attr("cx", function(td) {
      return chrLowXScale[data.pmark[td].chr](data.pmark[td].pos_cM);
    }).attr("cy", function(td) {
      return lodcurve_yScale(probe_data.lod[data.pmark[td].index]);
    }).attr("r", bigRad).attr("fill", purple).attr("stroke", "none").attr("stroke-width", "2").attr("opacity", 0).on("mouseover", function(td) {
      if (!markerClick[td]) {
        d3.select(this).attr("opacity", 1);
      }
      return martip.call(this, td);
    }).on("mouseout", function(td) {
      d3.select(this).attr("opacity", markerClick[td]);
      return d3.selectAll("#martip").remove();
    }).on("click", function(td) {
      var chr, pos, title;
      pos = data.pmark[td].pos_cM;
      chr = data.pmark[td].chr;
      title = td + " (chr " + chr + ", " + (onedig(pos)) + " cM)";
      d3.select("text#pxgtitle").text(title);
      if (lastMarker === "") {
        plotPXG(td);
      } else {
        markerClick[lastMarker] = 0;
        d3.select("circle#marker_" + lastMarker).attr("opacity", 0).attr("fill", purple).attr("stroke", "none");
        revPXG(td);
      }
      lastMarker = td;
      markerClick[td] = 1;
      return d3.select(this).attr("opacity", 1).attr("fill", altpink).attr("stroke", purple);
    });
    draw_pxgXaxis = function(means, genotypes, chr, sexcenter, male) {
      pxgXaxis.selectAll("line.PXGvert").data(means).enter().append("line").attr("class", "PXGvert").attr("y1", top[2]).attr("y2", bottom[2]).attr("x1", function(d, i) {
        if (chr === "X") {
          return pxgXscaleX(i);
        } else {
          return pxgXscaleA(i);
        }
      }).attr("x2", function(d, i) {
        if (chr === "X") {
          return pxgXscaleX(i);
        } else {
          return pxgXscaleA(i);
        }
      }).attr("stroke", darkGray).attr("fill", "none").attr("stroke-width", "1");
      pxgXaxis.selectAll("line.PXGvert").data(means).transition().duration(fasttime).attr("x1", function(d, i) {
        if (chr === "X") {
          return pxgXscaleX(i);
        } else {
          return pxgXscaleA(i);
        }
      }).attr("x2", function(d, i) {
        if (chr === "X") {
          return pxgXscaleX(i);
        } else {
          return pxgXscaleA(i);
        }
      });
      pxgXaxis.selectAll("line.PXGvert").data(means).exit().remove();
      pxgXaxis.selectAll("text.PXGgeno").data(genotypes).enter().append("text").attr("class", "PXGgeno").text(function(d) {
        return d;
      }).attr("y", bottom[2] + pad.bottom * 0.25).attr("x", function(d, i) {
        if (chr === "X") {
          return pxgXscaleX(i);
        } else {
          return pxgXscaleA(i);
        }
      }).attr("fill", labelcolor);
      pxgXaxis.selectAll("text.PXGgeno").data(genotypes).transition().duration(fasttime).text(function(d) {
        return d;
      }).attr("x", function(d, i) {
        if (chr === "X") {
          return pxgXscaleX(i);
        } else {
          return pxgXscaleA(i);
        }
      });
      pxgXaxis.selectAll("text.PXGgeno").data(genotypes).exit().remove();
      pxgXaxis.selectAll("text.PXGsex").data(["Female", "Male"]).enter().append("text").attr("class", "PXGsex").attr("id", "sextext").text(function(d) {
        return d;
      }).attr("y", bottom[j] + pad.bottom * 0.75).attr("x", function(d, i) {
        return sexcenter[i];
      }).attr("fill", labelcolor);
      pxgXaxis.selectAll("text.PXGsex").data(["Female", "Male"]).transition().duration(fasttime).attr("x", function(d, i) {
        return sexcenter[i];
      });
      pxgXaxis.selectAll("text.PXGsex").data(["Female", "Male"]).exit().remove();
      meanmarks.selectAll("line.PXGmeans").data(means).enter().append("line").attr("class", "PXGmeans").attr("x1", function(d, i) {
        if (chr === "X") {
          return pxgXscaleX(i) - jitterAmount * 3;
        } else {
          return pxgXscaleA(i) - jitterAmount * 3;
        }
      }).attr("x2", function(d, i) {
        if (chr === "X") {
          return pxgXscaleX(i) + jitterAmount * 3;
        } else {
          return pxgXscaleA(i) + jitterAmount * 3;
        }
      }).attr("y1", function(d) {
        return pxgYscale(d);
      }).attr("y2", function(d) {
        return pxgYscale(d);
      }).attr("stroke", function(d, i) {
        if (male[i]) {
          return darkblue;
        } else {
          return darkred;
        }
      }).attr("stroke-width", 4).on("mouseover", efftip).on("mouseout", function() {
        return d3.selectAll("#efftip").remove();
      });
      meanmarks.selectAll("line.PXGmeans").data(means).transition().duration(slowtime).attr("x1", function(d, i) {
        if (chr === "X") {
          return pxgXscaleX(i) - jitterAmount * 3;
        } else {
          return pxgXscaleA(i) - jitterAmount * 3;
        }
      }).attr("x2", function(d, i) {
        if (chr === "X") {
          return pxgXscaleX(i) + jitterAmount * 3;
        } else {
          return pxgXscaleA(i) + jitterAmount * 3;
        }
      }).attr("y1", function(d) {
        return pxgYscale(d);
      }).attr("y2", function(d) {
        return pxgYscale(d);
      }).attr("stroke", function(d, i) {
        if (male[i]) {
          return darkblue;
        } else {
          return darkred;
        }
      });
      return meanmarks.selectAll("line.PXGmeans").data(means).exit().remove();
    };
    pxgYscale = null;
    pxgXaxis = svg.append("g").attr("class", "probe_data").attr("id", "pxg_xaxis");
    pxgYaxis = svg.append("g").attr("class", "probe_data").attr("class", "plotPXG").attr("id", "pxg_yaxis");
    meanmarks = svg.append("g").attr("id", "pxgmeans").attr("class", "probe_data");
    plotPXG = function(marker) {
      var chr, genotypes, male, means, n, pxgticks, sexcenter, sx, x;
      pxgYscale = d3.scale.linear().domain([d3.min(probe_data.pheno), d3.max(probe_data.pheno)]).range([bottom[2] - pad.inner, top[2] + pad.inner]);
      pxgticks = pxgYscale.ticks(8);
      pxgYaxis.selectAll("empty").data(pxgticks).enter().append("line").attr("y1", function(d) {
        return pxgYscale(d);
      }).attr("y2", function(d) {
        return pxgYscale(d);
      }).attr("x1", left[2]).attr("x2", right[2]).attr("stroke", "white").attr("stroke-width", "1");
      pxgYaxis.selectAll("empty").data(pxgticks).enter().append("text").text(function(d) {
        return twodig(d);
      }).attr("y", function(d) {
        return pxgYscale(d);
      }).attr("x", left[2] - pad.left * 0.1).style("text-anchor", "end").attr("fill", labelcolor);
      chr = data.pmark[marker].chr;
      if (chr === "X") {
        means = [0, 0, 0, 0];
        n = [0, 0, 0, 0];
        male = [0, 0, 1, 1];
        genotypes = ["BR", "RR", "BY", "RY"];
        sexcenter = [(pxgXscaleX(0) + pxgXscaleX(1)) / 2, (pxgXscaleX(2) + pxgXscaleX(3)) / 2];
      } else {
        means = [0, 0, 0, 0, 0, 0];
        n = [0, 0, 0, 0, 0, 0];
        male = [0, 0, 0, 1, 1, 1];
        genotypes = ["BB", "BR", "RR", "BB", "BR", "RR"];
        sexcenter = [pxgXscaleA(1), pxgXscaleA(4)];
      }
      for (i in data.individuals) {
        g = Math.abs(data.geno[marker][i]);
        sx = data.sex[i];
        if (data.pmark[marker].chr === "X") {
          x = sx * 2 + g - 1;
        } else {
          x = sx * 3 + g - 1;
        }
        means[x] += probe_data.pheno[i];
        n[x]++;
      }
      for (i in means) {
        means[i] /= n[i];
      }
      draw_pxgXaxis(means, genotypes, chr, sexcenter, male);
      return svg.append("g").attr("id", "plotPXG").attr("class", "probe_data").attr("id", "PXGpoints").selectAll("empty").data(probe_data.pheno).enter().append("circle").attr("class", "plotPXG").attr("cx", function(d, i) {
        g = Math.abs(data.geno[marker][i]);
        sx = data.sex[i];
        if (data.pmark[marker].chr === "X") {
          return pxgXscaleX(sx * 2 + g - 1) + jitter[i];
        }
        return pxgXscaleA(sx * 3 + g - 1) + jitter[i];
      }).attr("cy", function(d) {
        return pxgYscale(d);
      }).attr("r", peakRad).attr("fill", function(d, i) {
        g = data.geno[marker][i];
        if (g < 0) {
          return pink;
        }
        return darkGray;
      }).attr("stroke", function(d, i) {
        g = data.geno[marker][i];
        if (g < 0) {
          return purple;
        }
        return "black";
      }).attr("stroke-width", function(d, i) {
        g = data.geno[marker][i];
        if (g < 0) {
          return "2";
        }
        return "1";
      }).on("mouseover", function(d, i) {
        d3.select(this).attr("r", bigRad);
        return indtip.call(this, d, i);
      }).on("mouseout", function() {
        d3.selectAll("#indtip").remove();
        return d3.select(this).attr("r", peakRad);
      });
    };
    revPXG = function(marker) {
      var chr, genotypes, male, means, n, sexcenter, sx, x;
      chr = data.pmark[marker].chr;
      if (chr === "X") {
        means = [0, 0, 0, 0];
        n = [0, 0, 0, 0];
        male = [0, 0, 1, 1];
        genotypes = ["BR", "RR", "BY", "RY"];
        sexcenter = [(pxgXscaleX(0) + pxgXscaleX(1)) / 2, (pxgXscaleX(2) + pxgXscaleX(3)) / 2];
      } else {
        means = [0, 0, 0, 0, 0, 0];
        n = [0, 0, 0, 0, 0, 0];
        male = [0, 0, 0, 1, 1, 1];
        genotypes = ["BB", "BR", "RR", "BB", "BR", "RR"];
        sexcenter = [pxgXscaleA(1), pxgXscaleA(4)];
      }
      for (i in data.individuals) {
        g = Math.abs(data.geno[marker][i]);
        sx = data.sex[i];
        if (data.pmark[marker].chr === "X") {
          x = sx * 2 + g - 1;
        } else {
          x = sx * 3 + g - 1;
        }
        means[x] += probe_data.pheno[i];
        n[x]++;
      }
      for (i in means) {
        means[i] /= n[i];
      }
      draw_pxgXaxis(means, genotypes, chr, sexcenter, male);
      return svg.selectAll("circle.plotPXG").transition().duration(slowtime).attr("cx", function(d, i) {
        g = Math.abs(data.geno[marker][i]);
        sx = data.sex[i];
        if (data.pmark[marker].chr === "X") {
          return pxgXscaleX(sx * 2 + g - 1) + jitter[i];
        }
        return pxgXscaleA(sx * 3 + g - 1) + jitter[i];
      }).attr("fill", function(d, i) {
        g = data.geno[marker][i];
        if (g < 0) {
          return pink;
        }
        return darkGray;
      }).attr("stroke", function(d, i) {
        g = data.geno[marker][i];
        if (g < 0) {
          return purple;
        }
        return "black";
      }).attr("stroke-width", function(d, i) {
        g = data.geno[marker][i];
        if (g < 0) {
          return "2";
        }
        return "1";
      });
    };
    lastMarker = maxlod_marker;
    markerClick[lastMarker] = 1;
    d3.select("circle#marker_" + lastMarker).attr("opacity", 1).attr("fill", altpink).attr("stroke", purple);
    pos = data.pmark[lastMarker].pos_cM;
    chr = data.pmark[lastMarker].chr;
    title = lastMarker + " (chr " + chr + ", " + (onedig(pos)) + " cM)";
    d3.select("text#pxgtitle").text(title);
    return plotPXG(lastMarker);
  };
  chrindex = {};
  ref10 = data.chrnames;
  for (i = aa = 0, len10 = ref10.length; aa < len10; i = ++aa) {
    c = ref10[i];
    chrindex[c] = i;
  }
  peaks = svg.append("g").attr("id", "peaks").selectAll("empty").data(data.peaks).enter().append("circle").attr("class", function(d) {
    return "probe_" + d.probe;
  }).attr("cx", function(d) {
    return chrXScale[d.chr](d.pos_cM);
  }).attr("cy", function(d) {
    return chrYScale[data.probes[d.probe].chr](data.probes[d.probe].pos_cM);
  }).attr("r", peakRad).attr("stroke", "none").attr("fill", function(d) {
    if (chrindex[d.chr] % 2 === 0) {
      return darkblue;
    } else {
      return darkgreen;
    }
  }).attr("opacity", function(d) {
    return Zscale(d.lod);
  }).on("mouseover", function(d) {
    d3.selectAll("circle.probe_" + d.probe).attr("r", bigRad).attr("fill", pink).attr("stroke", darkblue).attr("stroke-width", 1).attr("opacity", 1);
    return eqtltip.call(this, d);
  }).on("mouseout", function(d) {
    d3.selectAll("circle.probe_" + d.probe).attr("r", peakRad).attr("fill", function(d) {
      if (chrindex[d.chr] % 2 === 0) {
        return darkblue;
      } else {
        return darkgreen;
      }
    }).attr("stroke", "none").attr("opacity", function(d) {
      return Zscale(d.lod);
    });
    return d3.selectAll("#eqtltip").remove();
  }).on("click", function(d) {
    return d3.json("Data/probe_data/probe" + d.probe + ".json", draw_probe);
  });
  d3.json("Data/probe_data/probe517761.json", draw_probe);
  results = [];
  for (j in left) {
    results.push(svg.append("rect").attr("x", left[j]).attr("y", top[j]).attr("height", h[j]).attr("width", w[j]).attr("class", "outerBox"));
  }
  return results;
};

stop_cistrans = function() {
  return d3.selectAll("div#cistrans svg").remove();
};
